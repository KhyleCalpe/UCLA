/*
 * nn.c
 *
 *  Created on: Dec 1, 2020
 *      Author: kcalp
 */

#include "nn.h"
#include <math.h>

// layer sizes
#define SIZE_1 5

// pre-processing parameters
float x1_offset[13] = {-0.972664,-3.598621,-4.089238,-9.096411,-5.981245,-10.730378,-7.866311,-7.67324,-6.784606,-4.057698,-5.818746,-5.029714,-3.892615};
float x1_gain[13] = {0.112057712411277,0.122436935795295,0.116694338784204,0.106512499055367,0.164255235553506,0.126104470239534,0.151653293879212,0.189742987431235,0.21134886331826,0.211364163332925,0.20356677488955,0.257818374431946,0.25879649278993};
float x1_ymin = -1.0;

// bias and weights
// weights treated as 2D arrays
float b1[SIZE_1] = {-1.5905010313908991559,0.39581547274370548761,1.1274547977584556957,-0.3261773060144587677,-0.90033767514813800581};
float w1[13*SIZE_1] = {-1.8875119400419715365,-0.43710324919253523701,1.8415861505293087408,0.75032148878199766973,0.82139351179594999319,-0.24677138879780297076,1.5764785786550756796,-0.60283838138664747053,-1.748791194253302983,0.12046887932048484793,-0.55011144367791131593,-0.0093076531120892640192,-0.018744344170669550997,2.5305381858149220697,2.0415831709166480934,-1.1346613999844619158,-1.0181934969071211317,-0.73414597766985378868,0.098264248675732815408,-0.8060264097110489967,1.1283302700907746896,1.1764800376382487102,-0.30555652177589642804,0.6937955593531681675,-0.77068850171989700115,-0.66261009097139023094,-1.4483366008706495265,0.61574635187444859419,2.4727734138626398241,1.5289757375273773654,-0.25508835147818692546,-1.3862521489814623177,-0.56579498720838794501,-0.31482863524843912595,0.77776323304091943278,0.75436957722800479509,-0.57489936378125372496,0.55646603836062946691,0.801877938784289368,0.88841266316389255753,-1.5724425017792376114,-1.0652432671242548778,-0.34913103894747538058,-1.3338351050323966618,-1.4919797720842853384,-1.0138625887221843769,0.089937466638165292077,0.5749799484752042833,0.46238267656958909058,-0.49451745160664689616,1.0509295502025659541,0.87126361733669199783,0.033304957171665622306,-1.7016387842276168296,-2.0954620618294947931,-1.2366965124915447749,0.013021337793420090928,1.586046684288422437,0.2409691676946529304,1.3694490400539480746,0.55318094333074019353,-0.47288541362085045883,0.99220009998952340968,0.52651499262863687978,0.16674362329813788297};

float b2[4] = {0.057434427984952532431,0.16844782674051334004,0.35110775039969133182,-1.1162032443974676532};
float w2[SIZE_1*4] = {-1.1075600611686127195,1.3023360213642451999,-4.6985461984203329422,1.0370987200514791837,2.2427808555946171509,-1.7809020170342091394,-2.3443238176766514336,1.7966661261315339804,5.1821208817341553043,-2.7354850089290150272,3.7959025503354788533,-2.7331916223458527782,2.652287594529816328,-3.2822533314251076675,1.5289040989849584928,-1.8012874661197384452,1.9219288385982458145,0.30138657604297802717,-4.4777303148148401846,-1.1590509103538593205};

void dense_Sig(float input[], double output[], int input_size, int output_size)
{
	// fully connected layer using tanh
	for (int row=0; row<output_size; row++)
	{
		for (int col=0; col<input_size; col++)
		{
			// dot product
			output[row] += (w1[col + row*input_size] * input[col]);
		}
		output[row] += b1[row];
		// tanh activation function
		output[row] = 2.0/(1 + exp(-2.0 * output[row])) - 1.0;
	}
}

void dense_S(double input[], double output[], int input_size, int output_size)
{
	// fully connected layer using softmax
	double output_sum = 0;

	for (int row=0; row<output_size; row++)
	{
		// dot product
		for (int col=0; col<input_size; col++)
			output[row] += (w2[col + row*input_size] * input[col]);

		// add bias
		output[row] = exp((double) (output[row] + b2[row]));
		output_sum += output[row];
	}

	// normalizing for probability
	for (int i=0; i<output_size; i++)
		output[i] /= output_sum;
}
